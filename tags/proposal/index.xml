<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>proposal on 我的日记</title><link>http://blog.heyuhua.com/tags/proposal/</link><description>Recent content in proposal on 我的日记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>何育华版权所有</copyright><lastBuildDate>Thu, 09 Jan 2020 11:30:34 +0800</lastBuildDate><atom:link href="http://blog.heyuhua.com/tags/proposal/index.xml" rel="self" type="application/rss+xml"/><item><title>Vertical Scaling of Pods | pod热缩放</title><link>http://blog.heyuhua.com/p/vertical-scaling-of-pods-pod%E7%83%AD%E7%BC%A9%E6%94%BE/</link><pubDate>Thu, 09 Jan 2020 11:30:34 +0800</pubDate><guid>http://blog.heyuhua.com/p/vertical-scaling-of-pods-pod%E7%83%AD%E7%BC%A9%E6%94%BE/</guid><description>&lt;p>这里缅怀 gonum社区的一位杰出贡献者. Sonia Keys.&lt;/p>
&lt;p>Sonia 是一位 业余天文学家，在03年被授予太平洋天文学杰出贡献奖。Golang 狂热爱好者， golang社区 数学及图形相关项目作者。&lt;/p>
&lt;hr>
&lt;p>OCI 协议中定义了 update api，但是上层的 k8s 编排层却一直缺少了相关的 container 热更新机制。在新产品的 技术调研中， kyle发现了上述功能提案，这里详细概括之。&lt;/p>
&lt;p>Vertical pod auto scaler， &lt;a class="link" href="https://cloud.google.com/kubernetes-engine/docs/concepts/verticalpodautoscaler?hl=zh-cn" target="_blank" rel="noopener"
>GKE 文档&lt;/a> 有详细的中文介绍， 社区一般将该功能简称为 VPA. 设计目的是为了能够调整 pod CPU / Memory 的request limit限制。&lt;/p>
&lt;p>这里我们希望在 VPA 实现中寻找一个方式能够有所帮助，或者能给予启发。&lt;/p>
&lt;p>摘抄自 GKE：&lt;/p>
&lt;blockquote>
&lt;h2 id="概览">概览&lt;/h2>
&lt;p>垂直 Pod 自动扩缩 (VPA) 使您不必考虑为容器的 CPU 请求和内存求指定具体的值。自动调节程序可以为 CPU 和内存请求和限制建议值，也可以自动更新值。&lt;/p>
&lt;p>垂直 Pod 自动扩缩提供以下好处：&lt;/p>
&lt;ul>
&lt;li>因为 Pod 完全用其所需，所以集群节点使用效率高。&lt;/li>
&lt;li>Pod 会被安排到具有适当可用资源的节点上。&lt;/li>
&lt;li>您不必运行耗时的基准测试任务来确定 CPU 和内存请求的正确值。&lt;/li>
&lt;li>自动调节程序可以随时调整 CPU 和内存请求，而无需您执行任何操作，所以维护时间更短。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>ok ，别人家的瓜只能吃到这里了。&lt;/p>
&lt;p>漫长的 G站扫街环节后。。。&lt;/p>
&lt;p>该功能的设计环节较为挫折，第一次参与人数较多的 讨论发生在 16年年初，隶属于 sig-node 小组，之后被重新分配到了 sig-autoscaling 小组下。 大概经过了 3年左右的开发周期。 将在近期（k8s 1.18 ）GA.&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/autoscaling/vertical-pod-autoscaler.md" title="设计实现方案"
target="_blank" rel="noopener"
>设计方案&lt;/a>详细描写了技术细节。这里会挑一些重点介绍。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;h3 id="技术细节">技术细节&lt;/h3>
&lt;ul>
&lt;li>&lt;a class="link" href="https://kubernetes.io/docs/user-guide/compute-resources/" target="_blank" rel="noopener"
>资源计算&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/resource-qos.md" target="_blank" rel="noopener"
>资源Qos&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://kubernetes.io/docs/admin/admission-controllers/" target="_blank" rel="noopener"
>准入控制&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://kubernetes.io/docs/admin/extensible-admission-controllers/#external-admission-webhooks" target="_blank" rel="noopener"
>外部准入控制&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="目标">目标：&lt;/h3>
&lt;ol>
&lt;li>引入自动维护，减少维护成本。&lt;/li>
&lt;li>提高资源利用率，减少container OOM 发生的情况。&lt;/li>
&lt;/ol>
&lt;h3 id="相关功能">相关功能&lt;/h3>
&lt;h4 id="hpa-horizontal-pod-autoscaler">HPA( Horizontal Pod Autoscaler)&lt;/h4>
&lt;p>横向扩展， 通过监听 cpu 压力和其他用户指定的 metric 动态缩扩。一般情况下 用户将会对无状态负载制定 HPA 方案，对有状态服务设置 VPA.&lt;/p>
&lt;h4 id="ca-cluster-autoscaler">CA (Cluster Autoscaler)&lt;/h4>
&lt;p>自动进行集群大小的配置。 可以和 VPA, HPA 组成完整的自动化伸缩方案。&lt;/p>
&lt;h4 id="initial-resources">initial resources&lt;/h4>
&lt;p>概念性的功能，基于历史利用率指标， 可以在pod创建时给予resource建议。 VPA 会覆盖重写该功能。&lt;/p>
&lt;h4 id="resource-estimation">Resource estimation&lt;/h4>
&lt;p>资源预算, 旨在提高节点资源的利用率。通过临时回收容器当前未使用的资源。 可以对标虚拟化的 DMC.概念和实现。使用Node pod 短时间时序数据进行资源回收和释放。 该功能与 VPA 互补。 仍处于&lt;strong>设计阶段&lt;/strong>。&lt;/p>
&lt;h3 id="需求">需求&lt;/h3>
&lt;h4 id="功能特性">功能特性&lt;/h4>
&lt;ol>
&lt;li>VPA 可以修改 POD 的资源 request/limit&lt;/li>
&lt;li>VPA 可以对 CPU 高负载， 内存 OOM 的事件作出相应。&lt;/li>
&lt;li>重启 VPA 管理下的 pod 可以遵循破坏预算功能（disruption budget）&lt;/li>
&lt;li>VPA 可配置：用户可以制定 VPA 动态缩扩的上下限。&lt;/li>
&lt;li>VPA 支持 pod controller,至少支持 deployment.&lt;/li>
&lt;/ol>
&lt;p>&amp;hellip;..&lt;/p>
&lt;p>其他:&lt;/p>
&lt;pre>&lt;code>- 高可用的
- 在 in-place update 功能完成后可以自动支持。（我们关注的重点之一）
&lt;/code>&lt;/pre>
&lt;h3 id="设计">设计&lt;/h3>
&lt;ol>
&lt;li>添加了一个 新的 API Server资源&lt;code>vertialPodAutoscaler&lt;/code>, 包含了一个&lt;strong>label selector&lt;/strong>去筛选 pod，使用 &lt;strong>resources policy&lt;/strong>控制如何将pod 的配置更新， 并且给出推荐的 pod resource 配置。&lt;/li>
&lt;li>一个新的组件 &lt;strong>VPA Recommender&lt;/strong> ，从 &lt;code>metrics-server&lt;/code> 响应消费集群所有的 pod 资源负载信号， 和 OOM 信号.&lt;/li>
&lt;li>VPA Recommender &lt;strong>监听所有的 pods&lt;/strong>，持续计算针对这些pod 的推荐资源用量，并&lt;strong>存储在 VPA 对象中&lt;/strong>。&lt;/li>
&lt;li>VPA Recommender 还会额外的 暴露一个同步 API ，可以获取 POD 描述， 并且返回 推荐的 资源配置。&lt;/li>
&lt;li>所有的Pod 资源创建请求 会经由 VPA 的 &lt;strong>Admission Controller&lt;/strong>，如果pod 可以匹配到任何读经的 VPA 对象，该访问控制插件会将 pod 的 资源字段，如果 上面的 VPA recommender 不可访问， 则会降级到使用已经缓存的vpa资源。&lt;/li>
&lt;li>另一个独立组件 &lt;strong>VPA Updater&lt;/strong>，负责实施更新 pods，如果一个 pod 使用 “&lt;code>auto&lt;/code>”模式的 VPA 配置，则该组件可以自动决定更新其 resource 配置到推荐值。这里要求 pod资源需要隶属于其他上层抽象管理资源，如 &lt;code>replicaset&lt;/code>等,可以在 pod因为修改配置后被销毁后重新创建。 在之后的更新中， Updater 会引入 &lt;code>in-place-update&lt;/code> 模式, 可以绕过 上述管理资源，因其可以直接在pod不销毁的情况下进行资源修改。&lt;/li>
&lt;li>CPA 之 控制资源的 下限，即 resource 的 request，但会将其limit设置为 infinity. 其 request 的数值根据 当前和之前运行时的 监控数据计算得出。&lt;/li>
&lt;li>新组件：&lt;strong>History Storage&lt;/strong>，同样的， 会消费来自 API Server 的资源利用率和OOM 事件（与 Recommender 组件相同），并且将其持久化存储。 该组件被 Recommender 用作在 启动时初始化。 可以由任意数据库支持。 MVP版本使用 Prometheus, 至少对于 资源使用率的部分是这样的。&lt;/li>
&lt;/ol>
&lt;h4 id="架构图">架构图&lt;/h4>
&lt;p>&lt;img src="http://qiniu.heyuhua.com/blog/post/vpa-architecture.png"
loading="lazy"
alt="vpa-architecture"
>&lt;/p>
&lt;h4 id="api">API&lt;/h4>
&lt;p>上面的 API 对象 &lt;code>verticalPodAutoscaler&lt;/code> 的一些详细信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">// VerticalPodAutoscalerSpec is the specification of the behavior of the autoscaler.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type VerticalPodAutoscalerSpec {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // A label query that determines the set of pods controlled by the Autoscaler.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Selector *metav1.LabelSelector
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // Describes the rules on how changes are applied to the pods.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // +optional
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> UpdatePolicy PodUpdatePolicy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // Controls how the autoscaler computes recommended resources.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // +optional
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ResourcePolicy PodResourcePolicy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// VerticalPodAutoscalerStatus describes the runtime state of the autoscaler.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type VerticalPodAutoscalerStatus {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // The time when the status was last refreshed.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> LastUpdateTime metav1.Time
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // The most recently computed amount of resources recommended by the
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // autoscaler for the controlled pods.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // +optional
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Recommendation RecommendedPodResources
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // A free-form human readable message describing the status of the autoscaler.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> StatusMessage string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h5 id="selector">Selector&lt;/h5>
&lt;p>指明了 哪些pod会被 VPA 控制。 也就是说 用户需要在编辑 pod时确保 label中包含了 VPA的信息。&lt;/p>
&lt;h5 id="update-policy">Update Policy&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;updatePolicy&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;mode&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>模式指定。 VPA 包含三种resource 自动伸缩策略。&lt;/p>
&lt;ol>
&lt;li>&amp;ldquo;&lt;code>Initial&lt;/code>&amp;rdquo;: VPA 只在 创建 pod时指定资源，在之后的pod生命周期中都不做修改。&lt;/li>
&lt;li>&amp;ldquo;&lt;code>Auto&lt;/code>&amp;quot;(defualt): 可以在 Pod 创建和运行时更新，包括驱逐， 重新规划（reschedule).&lt;/li>
&lt;li>&amp;ldquo;off&amp;rdquo;：没什么卵用的开发用功能。不作为，但是会记录运行时metric.&lt;/li>
&lt;/ol>
&lt;h5 id="resource-policy">Resource Policy&lt;/h5>
&lt;p>资源上下限。自动伸缩波动范围 threshold.&lt;/p>
&lt;p>写到这里应该是差不多了。 后面的实现细节并不设计 resource in-place update 相关内容。&lt;/p></description></item></channel></rss>